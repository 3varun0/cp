/*
Find the incurring minimum cost along with no. of paths
to reach from (0,0) to (x,y)
and
also print ALL the paths.
*/

#include <bits/stdc++.h>
using namespace std;
#define MP make_pair

int n, m;
int arr[1001][1001];
bool done[1001][1001];
pair<int,int> dp [1001][1001];

pair<int,int> rec(int x, int y) {//min cost to reach (x,y) from (0,0), # of such paths
    //pruning
    if (x<0 || x>n || y<0 || y>m) return MP(1e9,0);
    
    //base case
    if(x==0 && y==0) {
        return MP(arr[0][0], 1);
    }
    
    //cache check
    if (done[x][y]) return dp[x][y];
    
    //transition
    pair<int, int> ans = MP(1e9, 0);
    pair<int, int> temp1 = rec(x-1, y);
    pair<int, int> temp2 = rec(x, y-1);
    if (temp1.first == temp2.first) {//when both ways the costs are same
        ans.first = temp1.first + arr[x][y];
        ans.second = temp1.second + temp2.second;
    } else if (temp1.first < temp2.first) {//when cost from left-move is least
        ans.first = temp1.first + arr[x][y];
        ans.second = temp1.second;
    } else {
        ans.first = temp2.first + arr[x][y];//when cost from up-move is least
        ans.second = temp2.second;
    }
    
    //save and return
    dp[x][y] = ans;
    done[x][y] = true;
    return ans;
}
vector<vector<pair<int,int>>> allpaths;
vector<pair<int,int>> curpath;
void generate(int x, int y) {//print path to reach (x,y) from (0,0)
    
    //base case
    if(x==0 && y==0) {
        //return MP(arr[0][0], 1);
        allpaths.push_back(curpath);
        return;
    }
    
    //transition
    auto state_ans = rec(x, y);
    
    pair<int, int> temp1 = rec(x-1, y);
    pair<int, int> temp2 = rec(x, y-1);
    
    if (state_ans.first == temp1.first + arr[x][y]) {//when both ways the costs are same
        curpath.push_back(MP(x,y));
        generate(x-1, y);
        curpath.pop_back();
    } 
    if (state_ans.first == temp2.first + arr[x][y]) {
        curpath.push_back(MP(x,y));
        generate(x, y-1);
        curpath.pop_back();
    }
}

void solve () {
    cin>>n>>m;
    for (int i=0; i<=n; i++) {
        for (int j=0; j<=m; j++) {
            cin>>arr[i][j];
        }
    }
    
    //clearing the dp table 
    for (int i=0; i<=n; i++) {
        for (int j=0; j<=m; j++) {
            done[i][j] = false;
        }
    }
    
    
    auto ans = rec(n, m);
    cout<<ans.first<<" "<<ans.second<<endl;

    allpaths.clear();
    curpath.clear();
    generate(n, m);
    for (auto curpathv:allpaths) {
        for (auto y:curpathv)
        cout<<"("<<y.first<<","<<y.second<<")";
        cout<<endl;
    }
    
    
}

int main()
{
    int t;
    cin>>t;
    while (t--) {
        solve();
    }
    
    return 0;
}
---input
1
3 3
0 100 2 1
2 1000 1 2
1 1000 1000 3
100 100 100 0
---output
108 2
(3,3)(2,3)(1,3)(0,3)(0,2)(0,1)
(3,3)(2,3)(1,3)(1,2)(0,2)(0,1)