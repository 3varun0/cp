/*
Find the incurring minimum cost along with no. of paths
to reach from (0,0) to (x,y)
ans
also print the path
*/

#include <bits/stdc++.h>
using namespace std;
#define MP make_pair

int n, m;
int arr[1001][1001];
bool done[1001][1001];
pair<int,int> dp [1001][1001];

pair<int,int> rec(int x, int y) {//min cost to reach (x,y) from (0,0), # of such paths
    //pruning
    if (x<0 || x>n || y<0 || y>m) return MP(1e9,0);
    
    //base case
    if(x==0 && y==0) {
        return MP(arr[0][0], 1);
    }
    
    //cache check
    if (done[x][y]) return dp[x][y];
    
    //transition
    pair<int, int> ans = MP(1e9, 0);
    pair<int, int> temp1 = rec(x-1, y);
    pair<int, int> temp2 = rec(x, y-1);
    if (temp1.first == temp2.first) {//when both ways the costs are same
        ans.first = temp1.first + arr[x][y];
        ans.second = temp1.second + temp2.second;
    } else if (temp1.first < temp2.first) {//when cost from left-move is least
        ans.first = temp1.first + arr[x][y];
        ans.second = temp1.second;
    } else {
        ans.first = temp2.first + arr[x][y];//when cost from up-move is least
        ans.second = temp2.second;
    }
    
    //save and return
    dp[x][y] = ans;
    done[x][y] = true;
    return ans;
}
vector<pair<int,int>> solpath;
void generate(int x, int y) {//print path to reach (x,y) from (0,0)
    
    //base case
    if(x==0 && y==0) {
        //return MP(arr[0][0], 1);
        return;
    }
    
    //transition
    auto state_ans = rec(x, y);
    
    pair<int, int> temp1 = rec(x-1, y);
    pair<int, int> temp2 = rec(x, y-1);
    
    if (state_ans.first == temp1.first + arr[x][y]) {//when both ways the costs are same
        generate(x-1, y);
        solpath.push_back(MP(x,y));
    } else {
        generate(x, y-1);
        solpath.push_back(MP(x,y));
    }
}

void solve () {
    cin>>n>>m;
    for (int i=0; i<=n; i++) {
        for (int j=0; j<=m; j++) {
            cin>>arr[i][j];
        }
    }
    
    //clearing the dp table 
    for (int i=0; i<=n; i++) {
        for (int j=0; j<=m; j++) {
            done[i][j] = false;
        }
    }
    
    
    auto ans = rec(n, m);
    cout<<ans.first<<" "<<ans.second<<endl;

    solpath.clear();
    generate(n, m);
    for (auto x:solpath) {
        cout<<"("<<x.first<<","<<x.second<<")";
    }
    cout<<endl;
    
}

int main()
{
    int t;
    cin>>t;
    while (t--) {
        solve();
    }
    
    return 0;
}

---input
1
3 3
0 100 2 3
2 1000 1000 1
1 1000 1000 3
100 100 100 0
---output
109 1
(0,1)(0,2)(0,3)(1,3)(2,3)(3,3)